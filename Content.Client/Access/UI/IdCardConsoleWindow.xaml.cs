using System.Linq;
using Content.Client._Starlight.Access.UI; // Starlight-edit
using Content.Shared.Access;
using Content.Shared.Access.Systems;
using Content.Shared.CCVar;
using Content.Shared.Roles;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;
using static Content.Shared.Access.Components.IdCardConsoleComponent;

namespace Content.Client.Access.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class IdCardConsoleWindow : DefaultWindow
    {
        [Dependency] private readonly IConfigurationManager _cfgManager = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        [Dependency] private readonly ILogManager _logManager = default!;
        private readonly ISawmill _logMill = default!;

        private IdCardConsoleBoundUserInterface? _owner; // Starlight edit

        // CCVar.
        private int _maxNameLength;
        private int _maxIdJobLength;

        private AccessLevelControl _accessButtons = new();
        private AccessGroupControl _accessGroups = new(); // Starlight-edit: Access Groups
        private readonly List<string> _jobPrototypeIds = new();

        private string? _lastFullName;
        private string? _lastJobTitle;
        private string? _lastJobProto;

        // The job that will be picked if the ID doesn't have a job on the station.
        private static ProtoId<JobPrototype> _defaultJob = "Assistant";
        // Starlight-edit: Start
        private ProtoId<AccessGroupPrototype>? _selectedAccessGroup = null;
        public Action<ProtoId<AccessGroupPrototype>>? OnGroupSelected;

        private HashSet<ProtoId<AccessLevelPrototype>> _pendingPressedAccessLevels = new();
        private string? _lastTargetIdName = null;
        private HashSet<ProtoId<AccessLevelPrototype>> _allowedAccessLevels = new();

        private bool _pendingAccessOverride = false;

        public IdCardConsoleWindow()
        // Starlight-edit: End
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);
            _logMill = _logManager.GetSawmill(SharedIdCardConsoleSystem.Sawmill);

            // Starlight _owner = owner; // Starlight edit

            _maxNameLength = _cfgManager.GetCVar(CCVars.MaxNameLength);
            _maxIdJobLength = _cfgManager.GetCVar(CCVars.MaxIdJobLength);

            FullNameLineEdit.OnTextEntered += _ => SubmitData();
            FullNameLineEdit.IsValid = s => s.Length <= _maxNameLength;
            FullNameLineEdit.OnTextChanged += _ =>
            {
                FullNameSaveButton.Disabled = FullNameSaveButton.Text == _lastFullName;
            };
            FullNameSaveButton.OnPressed += _ => SubmitData();

            JobTitleLineEdit.OnTextEntered += _ => SubmitData();
            JobTitleLineEdit.IsValid = s => s.Length <= _maxIdJobLength;
            JobTitleLineEdit.OnTextChanged += _ =>
            {
                JobTitleSaveButton.Disabled = JobTitleLineEdit.Text == _lastJobTitle;
            };
            JobTitleSaveButton.OnPressed += _ => SubmitData();

            var jobs = _prototypeManager.EnumeratePrototypes<JobPrototype>().ToList();
            jobs.Sort((x, y) => string.Compare(x.LocalizedName, y.LocalizedName, StringComparison.CurrentCulture));

            foreach (var job in jobs)
            {
                if (!job.OverrideConsoleVisibility.GetValueOrDefault(job.SetPreference))
                {
                    continue;
                }

                _jobPrototypeIds.Add(job.ID);
                JobPresetOptionButton.AddItem(Loc.GetString(job.Name), _jobPrototypeIds.Count - 1);
            }

            JobPresetOptionButton.OnItemSelected += SelectJobPreset;
            // Starlight-edit: Start
            _accessGroups = new AccessGroupControl();
            _accessButtons = new AccessLevelControl();
            AccessGroupControlContainer.AddChild(_accessGroups);
            AccessLevelControlContainer.AddChild(_accessButtons);
            foreach (var (id, button) in _accessButtons.ButtonsList)
            {
                button.OnPressed += _ =>
                {
                    if (button.Pressed)
                        _pendingPressedAccessLevels.Add(id);
                    else
                        _pendingPressedAccessLevels.Remove(id);
                    SubmitData();
                };
            }
        }

        public void Initialize(IdCardConsoleBoundUserInterface owner)
        {
            _owner = owner;

            OnGroupSelected += group => _owner.OnGroupSelected(group);
            // Starlight-edit: End
        }

        private void ClearAllAccess()
        {
            _pendingPressedAccessLevels.Clear(); // Starlight-edit
            foreach (var button in _accessButtons.ButtonsList.Values)
                button.Pressed = false; // Starlight-edit
        }

        private void SelectJobPreset(OptionButton.ItemSelectedEventArgs args)
        {
            if (!_prototypeManager.TryIndex(_jobPrototypeIds[args.Id], out JobPrototype? job))
            {
                return;
            }

            JobTitleLineEdit.Text = Loc.GetString(job.Name);
            args.Button.SelectId(args.Id);

            ClearAllAccess();

            // Collect all access levels for this job (direct + all groups)
            // Starlight-edit: Start
            var allJobAccess = new HashSet<ProtoId<AccessLevelPrototype>>(job.Access);
            foreach (var group in job.AccessGroups)
            {
                if (_prototypeManager.Resolve(group, out AccessGroupPrototype? groupPrototype))
                    allJobAccess.UnionWith(groupPrototype.Tags);
            }

            // Get all tags from all groups in AccessGroups
            var allConsoleGroupTags = new HashSet<ProtoId<AccessLevelPrototype>>();
            foreach (var group in _accessGroups.ButtonsList.Keys)
            {
                if (_prototypeManager.TryIndex(group, out AccessGroupPrototype? groupProto))
                    allConsoleGroupTags.UnionWith(groupProto.Tags);
            }
            // Only allow access levels that are both allowed and present in the console's groups
            var allowedJobAccess = allJobAccess
                .Where(x => _allowedAccessLevels.Contains(x) && allConsoleGroupTags.Contains(x))
                .ToHashSet();
            _pendingPressedAccessLevels = allowedJobAccess;

            _pendingAccessOverride = true;

            // Update visible buttons to match pending pressed state
            foreach (var (access, button) in _accessButtons.ButtonsList)
                button.Pressed = _pendingPressedAccessLevels.Contains(access);
            // Starlight-edit: End
            SubmitData();
        }

        public void UpdateState(IdCardConsoleBoundUserInterfaceState state)
        {
            PrivilegedIdButton.Text = state.IsPrivilegedIdPresent
                ? Loc.GetString("id-card-console-window-eject-button")
                : Loc.GetString("id-card-console-window-insert-button");

            PrivilegedIdLabel.Text = state.PrivilegedIdName;

            TargetIdButton.Text = state.IsTargetIdPresent
                ? Loc.GetString("id-card-console-window-eject-button")
                : Loc.GetString("id-card-console-window-insert-button");

            TargetIdLabel.Text = state.TargetIdName;

            var interfaceEnabled =
                state.IsPrivilegedIdPresent && state.IsPrivilegedIdAuthorized && state.IsTargetIdPresent;

            var fullNameDirty = _lastFullName != null && FullNameLineEdit.Text != state.TargetIdFullName;
            var jobTitleDirty = _lastJobTitle != null && JobTitleLineEdit.Text != state.TargetIdJobTitle;

            FullNameLabel.Modulate = interfaceEnabled ? Color.White : Color.Gray;
            FullNameLineEdit.Editable = interfaceEnabled;
            if (!fullNameDirty)
            {
                FullNameLineEdit.Text = state.TargetIdFullName ?? string.Empty;
            }

            FullNameSaveButton.Disabled = !interfaceEnabled || !fullNameDirty;

            JobTitleLabel.Modulate = interfaceEnabled ? Color.White : Color.Gray;
            JobTitleLineEdit.Editable = interfaceEnabled;
            if (!jobTitleDirty)
            {
                JobTitleLineEdit.Text = state.TargetIdJobTitle ?? string.Empty;
            }

            JobTitleSaveButton.Disabled = !interfaceEnabled || !jobTitleDirty;

            JobPresetOptionButton.Disabled = !interfaceEnabled;

            // Starlight-edit: Start
            AccessGroupControlContainer.RemoveAllChildren();
            AccessLevelControlContainer.RemoveAllChildren();

            var allowedAccess = state.AllowedModifyAccessList != null
                ? state.AllowedModifyAccessList.ToList()
                : new List<ProtoId<AccessLevelPrototype>>();

            // Track allowed access for filtering on submit
            _allowedAccessLevels = allowedAccess.ToHashSet();

            var allPossibleAccess = _prototypeManager.EnumeratePrototypes<AccessLevelPrototype>()
                .Where(a => a.CanAddToIdCard)
                .Select(a => a.ID)
                .ToHashSet();

            var isHighPrivilege = allowedAccess.Count >= allPossibleAccess.Count * 0.8f;

            var groupsWithCoverage = new List<ProtoId<AccessGroupPrototype>>();
            if (allowedAccess.Count > 0)
            {
                List<ProtoId<AccessGroupPrototype>> groupsToCheck;
                if (state.AvailableAccessGroups != null)
                {
                    groupsToCheck = state.AvailableAccessGroups;
                }
                else
                {
                    groupsToCheck = _prototypeManager.EnumeratePrototypes<AccessGroupPrototype>()
                        .Select(p => (ProtoId<AccessGroupPrototype>)p.ID)
                        .ToList();
                }

                foreach (var groupId in groupsToCheck)
                {
                    if (!_prototypeManager.TryIndex(groupId, out var proto))
                        continue;

                    var groupTags = proto.Tags.Where(tag => 
                        _prototypeManager.TryIndex<AccessLevelPrototype>(tag, out var accessProto) && 
                        accessProto.CanAddToIdCard).ToList();
                    
                    if (groupTags.Count == 0)
                        continue;
                        
                    var matchingTags = groupTags.Count(tag => allowedAccess.Contains(tag));
                    var threshold = Math.Max(1, Math.Min(3, groupTags.Count / 2));
                    
                    if (matchingTags >= threshold)
                        groupsWithCoverage.Add(groupId);
                }
            }

            if (!state.IsTargetIdPresent)
            {
                AccessGroupControlContainer.Visible = false;
                AccessLevelControlContainer.Visible = false;
            }
            else
            {
                var showGroups = state.AvailableAccessGroups != null && groupsWithCoverage.Count > 1;

                // Groups control
                if (showGroups)
                {
                    ProtoId<AccessGroupPrototype> selectedGroup =
                        groupsWithCoverage.Contains(state.CurrentAccessGroup)
                            ? state.CurrentAccessGroup
                            : groupsWithCoverage.First();

                    _accessGroups.Populate(groupsWithCoverage, selectedGroup, _prototypeManager);
                    AccessGroupControlContainer.Visible = true;
                    AccessGroupControlContainer.AddChild(_accessGroups);

                    foreach (var (id, button) in _accessGroups.ButtonsList)
                    {
                        var groupId = id;
                        button.OnPressed += _ => _owner?.OnGroupSelected(groupId);
                    }
                }
                else
                {
                    AccessGroupControlContainer.Visible = false;
                }

                ProtoId<AccessGroupPrototype>? effectiveGroup =
                    showGroups ? (ProtoId<AccessGroupPrototype>?)state.CurrentAccessGroup : null;

                // Only reset _pendingPressedAccessLevels if the target ID changed,
                // and do NOT override if a job dropdown selection is pending
                if (_lastTargetIdName != state.TargetIdName || !_pendingAccessOverride)
                {
                    if (state.TargetIdAccessList != null)
                        _pendingPressedAccessLevels = state.TargetIdAccessList.ToHashSet();
                    else
                        _pendingPressedAccessLevels.Clear();
                }

                _lastTargetIdName = state.TargetIdName;

                // Update access buttons for current group
                _accessButtons.UpdateState(
                    _pendingPressedAccessLevels.ToList(),
                    showGroups ? (ProtoId<AccessGroupPrototype>?)state.CurrentAccessGroup : null,
                    _prototypeManager,
                    allowedAccess);
                AccessLevelControlContainer.Visible = true;
                AccessLevelControlContainer.AddChild(_accessButtons);

                // When a button is pressed, update global pressed state
                foreach (var (id, button) in _accessButtons.ButtonsList)
                {
                    button.OnPressed += _ =>
                    {
                        if (button.Pressed)
                            _pendingPressedAccessLevels.Add(id);
                        else
                            _pendingPressedAccessLevels.Remove(id);
                        SubmitData();
                    };
                }
            }
            // Starlight-end

            var jobIndex = _jobPrototypeIds.IndexOf(state.TargetIdJobPrototype);
            // If the job index is < 0 that means they don't have a job registered in the station records
            // or the IdCardComponent's JobPrototype field.
            // For example, a new ID from a box would have no job index.
            if (jobIndex < 0)
            {
                jobIndex = _jobPrototypeIds.IndexOf(_defaultJob);
            }

            JobPresetOptionButton.SelectId(jobIndex);

            _lastFullName = state.TargetIdFullName;
            _lastJobTitle = state.TargetIdJobTitle;
            _lastJobProto = state.TargetIdJobPrototype;
        }

        private void SubmitData()
        {
            var jobProtoDirty = _lastJobProto != null &&
                                _jobPrototypeIds[JobPresetOptionButton.SelectedId] != _lastJobProto;
            // Starlight-edit: Start
            // Only submit access levels that are allowed by the server
            var filteredAccess = _pendingPressedAccessLevels.Where(x => _allowedAccessLevels.Contains(x)).ToList();

            _owner?.SubmitData(
                FullNameLineEdit.Text,
                JobTitleLineEdit.Text,
                filteredAccess,
                jobProtoDirty ? _jobPrototypeIds[JobPresetOptionButton.SelectedId] : string.Empty);

            // Clear the override after submit so next UpdateState can update pressed state as normal
            _pendingAccessOverride = false;
            // Starlight-edit: End
        }
    }
}
